library(shiny)
install.packages('shiny')
library(shiny)
shiny::runApp('AppliV0')
library(shiny)
runApp('AppliV0')
library(shinydashboard)
runApp('AppliV0')
runApp('AppliV0')
library(plotly)
runApp('AppliV0')
source("http://bioconductor.org/biocLite.R")
BiocManager::install()
BiocManager::install("devtools")    # only if devtools not yet installed
BiocManager::install("pachterlab/sleuth")
BiocManager::install("rhdf5")
library(sleuth)
library('sleuth')
shiny::runApp('AppliV0')
library(shiny)
library(shinydashboard)
library(plotly)
shiny::runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp()
runApp('AppliV0')
runApp('AppliV0')
runApp()
runApp()
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp()
runApp('AppliV0')
runApp('AppliV0')
runApp()
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp()
runApp('AppliV0')
packages.install(ggiraph)
install.packages("ggiraph")
library(ggiraph)
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp('AppliV0')
runApp()
runApp('AppliV0')
run_girafe_example("DT")
system.file("shiny", package = "ggiraph")
run_girafe_example("DT")
runApp('AppliV0')
runApp('test_shiny')
install.packages("highcharter", repos = "http://cran.us.r-project.org")
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
library(highcharter)
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test2.R')
install.packages("MASS")
runApp('test2.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
runApp('test_graphe.R')
shiny::runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
shiny::runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
install.packages(c("FactoMineR", "factoextra"))
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
shiny::runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
shiny::runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0/V2')
runApp('AppliV0')
runApp('AppliV0/V2')
runApp('AppliV0')
runApp('AppliV0/V2')
shiny::runApp('V3')
runApp('V3')
runApp('V3')
shiny::runApp('V3')
runApp('V3')
shiny::runApp('V3')
install.packages(golem)
install.packages("golem")
translation = function(coord,nb_col,nb_line){
coord$xr = as.integer(row.names(coord))
dy = coord[order(coord$y, coord$x, decreasing=T),]
dx = coord[order(coord$x, coord$y, decreasing=T),]
deltax = median(diff(dx$x)) / median(diff(dx$y))
deltay = median(diff(dy$y)) / median(diff(dy$x))
coord$x = coord$x - (deltax * coord$y)
coord$y = coord$y - (deltay * coord$x)
dist_x=dist(coord$x)
clust_x=hclust(dist_x, "complete")
coord$gp_colonne = cutree(clust_x, k = nb_col)
coord = coord[order(coord$y),]
coord$gp_line = cutree(hclust(dist(coord$y), "complete"),k = nb_line)
coord = coord[order(coord$xr),]
return(list(gp_l = coord$gp_line, gp_c = coord$gp_colonne, deltax = deltax, deltay = deltay, d = coord))
}
# Cette fonction permet d'associé a chaque pixel un numero
# d'echantillon, cette fonction prend en compte l'absence
# d'echantillon a certains endroit
cluster=function(data,nb_line,nb_col){
coord_data = as.matrix(data)
dist = dist(coord_data)
hc = hclust(dist, method = 'single')
ct = cutree(hc, h = 7)
coord_data = as.data.frame(coord_data)
coord_data[,3] = ct
colnames(coord_data) = c('x','y','num')
centroide_x = tapply(X = coord_data[,1], coord_data[,3], mean)
centroide_y = tapply(X = coord_data[,2], coord_data[,3], mean)
centroide = as.data.frame(cbind(centroide_x, centroide_y))
colnames(centroide) = c('x', 'y')
deltax_prev = 0
deltay_prev = 0
res_translation=translation(centroide, nb_col, nb_line)
values_def = NULL
# Une transaltion est effectuer tant que l'on decale dans le meme sens
# cad tant que le deltax precedent et present dont du meme signe ( de meme pour delaty )
while(deltax_prev * res_translation$deltax >= 0 && deltay_prev * res_translation$deltay >= 0) {
values_def = res_translation
deltax_prev = res_translation$deltax
deltay_prev = res_translation$deltay
res_translation=translation(res_translation$d, nb_col, nb_line)
}
gp = as.data.frame(cbind(values_def$gp_l, values_def$gp_c))
colnames(gp) = c('line', 'col')
Min_x = tapply(X = coord_data$x,coord_data$num,min)
Max_x = tapply(X = coord_data$x,coord_data$num,max)
Min_y = tapply(X = coord_data$y,coord_data$num,min)
Max_y = tapply(X = coord_data$y,coord_data$num,max)
coord_sample = as.data.frame(cbind(Min_x,Max_x,Min_y,Max_y))
colnames(coord_sample) = c('minx', 'maxx', 'miny', 'maxy')
num_sample = c()
for (i in 1:dim(coord_sample)[1]) {
num = (gp$line[i]-1) * nb_col + gp$col[i]
num_sample = c(num_sample, num)
}
coord_sample$num = num_sample
return(coord_sample)
}
coo=read.table('Téléchargements/coord_data1.csv',sep=",",header=TRUE)
head(coo)
cluster(coo,8,12)
mean(centoide$x)
translation = function(coord,nb_col,nb_line){
coord$xr = as.integer(row.names(coord))
dy = coord[order(coord$y, coord$x, decreasing=T),]
dx = coord[order(coord$x, coord$y, decreasing=T),]
deltax = median(diff(dx$x)) / median(diff(dx$y))
deltay = median(diff(dy$y)) / median(diff(dy$x))
coord$x = coord$x - (deltax * coord$y)
coord$y = coord$y - (deltay * coord$x)
coord$gp_colonne = cutree(hclust(dist(coord$x), "complete"), k = nb_col)
coord = coord[order(coord$y),]
coord$gp_line = cutree(hclust(dist(coord$y), "complete"),k = nb_line)
coord = coord[order(coord$xr),]
return(list(gp_l = coord$gp_line, gp_c = coord$gp_colonne, deltax = deltax, deltay = deltay, d = coord))
}
clust_d1
clust_d2
data.frame(ncol=2)
library(Cardinal)
setwd("~/Application_ShinyDashboard/Differential_Analaysis_Rshiny")
golem::run_dev()
golem::run_dev()
golem::run_dev()
